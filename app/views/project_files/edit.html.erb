<%# app/views/project_files/edit.html.erb - Enhanced with AI Code Completion %>

<div class="editor-page-wrapper">
  <!-- Chat Toggle Button (moved to bottom right) -->
  <button id="chatToggleBtn" class="btn btn-primary chat-toggle-btn-bottom" onclick="toggleChatSidebar()">
    <i class="bi bi-chat-dots"></i>
    <span class="badge bg-danger chat-notification-badge" id="chatNotificationBadge" style="display: none;">0</span>
  </button>

  <!-- AI Completion Toggle Button -->
  <button id="aiToggleBtn" class="btn btn-success ai-toggle-btn" onclick="toggleAICompletion()" title="Toggle AI Completion (Ctrl+Alt+A)">
    <i class="bi bi-robot"></i>
    <span class="ai-status-indicator" id="aiStatusIndicator"></span>
  </button>

  <!-- Editor Container -->
  <div id="editorContainer" class="editor-container">
    <!-- Editor Header -->
    <div class="editor-header">
      <div class="editor-info">
        <span class="file-name">
          <i class="bi bi-file-earmark-code me-2 text-primary"></i>
          <span id="fileName"><%= @file_name %></span>
        </span>
        <span class="branch-badge">
          <i class="bi bi-git me-1"></i>
          <span id="branchName"><%= @branch_name %></span>
        </span>
        <span class="connection-status" id="connectionStatus">
          <i class="bi bi-circle-fill text-warning me-1"></i>
          <small class="text-muted">Connecting...</small>
        </span>
        <!-- AI Status in Header -->
        <span class="ai-status" id="aiHeaderStatus">
          <i class="bi bi-robot me-1"></i>
          <small class="text-muted" id="aiStatusText">AI Ready</small>
        </span>
      </div>
      
      <div class="editor-actions">
        <!-- Active Users -->
        <div class="active-users">
          <small class="text-muted me-2">Online:</small>
          <div id="activeUsers" class="users-list"></div>
        </div>
        
        <!-- Action Buttons -->
        <div class="action-buttons">
          <button id="saveBtn" class="btn btn-success btn-sm" <%= @can_edit ? '' : 'disabled' %>>
            <i class="bi bi-save me-1"></i>
            <span>Save</span>
          </button>
          
          <button id="commitBtn" class="btn btn-primary btn-sm" <%= @can_edit ? '' : 'disabled' %>>
            <i class="bi bi-check-circle me-1"></i>
            <span>Commit</span>
          </button>
          
          <button id="aiCompletionBtn" class="btn btn-outline-info btn-sm" onclick="triggerAICompletion()" title="Get AI Suggestions (Ctrl+Enter)">
            <i class="bi bi-lightbulb me-1"></i>
            <span>AI Complete</span>
          </button>
          
          <div class="dropdown">
            <button class="btn btn-outline-secondary btn-sm dropdown-toggle" type="button" data-bs-toggle="dropdown">
              <i class="bi bi-three-dots"></i>
            </button>
            <ul class="dropdown-menu dropdown-menu-end">
              <li><a class="dropdown-item" href="#" onclick="downloadFile()">
                <i class="bi bi-download me-2"></i>Download
              </a></li>
              <li><a class="dropdown-item" href="#" onclick="refreshEditor()">
                <i class="bi bi-arrow-clockwise me-2"></i>Refresh
              </a></li>
              <li><hr class="dropdown-divider"></li>
              <li><a class="dropdown-item" href="#" onclick="toggleAICompletion()">
                <i class="bi bi-robot me-2"></i>Toggle AI Completion
              </a></li>
              <li><hr class="dropdown-divider"></li>
              <li><a class="dropdown-item" href="<%= project_project_files_path(@project, path: @current_path) %>">
                <i class="bi bi-box-arrow-left me-2"></i>Back to Files
              </a></li>
            </ul>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Monaco Editor -->
    <div class="editor-main">
      <div id="monaco-editor"></div>
      
      <!-- AI Completion Popup -->
      <div id="aiCompletionPopup" class="ai-completion-popup" style="display: none;">
        <div class="ai-popup-header">
          <div class="d-flex justify-content-between align-items-center">
            <span class="fw-bold">
              <i class="bi bi-robot text-primary me-2"></i>
              AI Suggestions
            </span>
            <button class="btn-close btn-close-sm" onclick="hideAICompletionPopup()"></button>
          </div>
        </div>
        <div class="ai-suggestions-list" id="aiSuggestionsList">
          <!-- AI suggestions will be populated here -->
        </div>
        <div class="ai-popup-footer">
          <small class="text-muted">Press Tab to accept • Esc to dismiss • ↑↓ to navigate</small>
        </div>
      </div>
    </div>

    <!-- Editor Status Bar -->
    <div class="editor-status-bar">
      <div class="status-left">
        <span class="status-item" id="editorMode">
          <i class="bi bi-<%= @can_edit ? 'pencil' : 'eye' %> me-1"></i>
          <%= @can_edit ? 'Edit Mode' : 'Read Only' %>
        </span>
        <span class="status-item" id="cursorPosition">
          Line 1, Col 1
        </span>
        <span class="status-item" id="selectionInfo" style="display: none;">
          Selected: 0 chars
        </span>
        <span class="status-item" id="aiCompletionStatus">
          <i class="bi bi-robot me-1"></i>
          <span id="aiStatusMessage">Ready</span>
        </span>
      </div>
      
      <div class="status-right">
        <span class="status-item" id="languageMode">
          <i class="bi bi-code-slash me-1"></i>
          <%= @language.capitalize %>
        </span>
        <span class="status-item" id="lastSaved">
          <%= File.exist?("#{Rails.root.join('storage', 'projects', "project_#{@project.id}", @current_path, @file_name)}.unsaved") ? 'Unsaved changes' : 'Saved' %>
        </span>
      </div>
    </div>
  </div>

  <!-- Chat Sidebar -->
  <div id="chatSidebar" class="chat-sidebar">
    <!-- Chat Header -->
    <div class="chat-header">
      <div class="d-flex justify-content-between align-items-center">
        <div>
          <h6 class="mb-0 fw-bold">
            <i class="bi bi-chat-dots me-2 text-primary"></i>
            Team Chat
          </h6>
          <small class="text-muted">
            <span id="onlineCount">0</span> collaborators online
          </small>
        </div>
        
        <div class="d-flex gap-2">
          <button class="btn btn-sm btn-outline-secondary" onclick="clearChatHistory()" title="Clear chat">
            <i class="bi bi-trash3"></i>
          </button>
          <button class="btn btn-sm btn-outline-secondary" onclick="toggleChatSidebar()" title="Close chat">
            <i class="bi bi-x-lg"></i>
          </button>
        </div>
      </div>
    </div>
    
    <!-- Online Users List -->
    <div class="chat-users">
      <div class="chat-users-header">
        <small class="text-muted fw-semibold">ONLINE NOW</small>
      </div>
      <div id="chatUsersList" class="chat-users-list">
        <!-- Users will be populated here -->
      </div>
    </div>
    
    <!-- Chat Messages -->
    <div class="chat-messages" id="chatMessages">
      <div class="welcome-message">
        <div class="text-center text-muted py-4">
          <i class="bi bi-chat-heart fs-3 mb-2 d-block"></i>
          <p class="mb-0">Welcome to team chat!</p>
          <small>Start collaborating with your team members</small>
        </div>
      </div>
    </div>
    
    <!-- Typing Indicator -->
    <div class="typing-indicator" id="typingIndicator"></div>
    
    <!-- Chat Input -->
    <div class="chat-input">
      <div class="input-group">
        <input type="text" 
               id="messageInput" 
               class="form-control" 
               placeholder="Type a message..." 
               maxlength="500"
               autocomplete="off">
        <button class="btn btn-primary" 
                onclick="sendMessage()" 
                title="Send message (Enter)">
          <i class="bi bi-send"></i>
        </button>
      </div>
      
      <div class="chat-options mt-2">
        <div class="d-flex justify-content-end align-items-center">
          <small class="text-muted">
            <span id="messageLength">0</span>/500
          </small>
        </div>
      </div>
    </div>
  </div>

  <!-- Notifications Container -->
  <div id="notifications" class="notifications-container"></div>

  <!-- Conflict Modal -->
  <div class="modal fade" id="conflictModal" tabindex="-1" data-bs-backdrop="false" data-bs-keyboard="false">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">
            <i class="bi bi-exclamation-triangle text-warning me-2"></i>
            Edit Conflict Detected
          </h5>
          <button type="button" class="btn-close" onclick="closeConflictModal()"></button>
        </div>
        <div class="modal-body" id="conflictModalBody">
          <!-- Content will be inserted dynamically -->
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Monaco Editor Script -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs/loader.min.js"></script>

<!-- Rails Configuration Script -->
<script>
  // Configure the editor with Rails data
  window.editorConfig = {
    projectId: <%= @project.id %>,
    fileId: '<%= File.join(@current_path.to_s, @file_name).gsub(/^\//, '') %>',
    fileName: '<%= @file_name %>',
    branch: '<%= @branch_name %>',
    language: '<%= @language %>',
    initialContent: <%= @file_content.to_json.html_safe %>,
    userId: <%= current_user.id %>,
    userName: '<%= current_user.username.presence || current_user.email %>',
    canEdit: <%= @can_edit ? 'true' : 'false' %>,
    savePath: '<%= save_project_project_file_path(@project, @file_name, path: @current_path) %>',
    commitPath: '<%= commit_project_project_file_path(@project, @file_name, path: @current_path) %>',
    currentPath: '<%= @current_path %>',
    projectPath: '<%= project_project_files_path(@project, path: @current_path) %>',
    aiCompletionPath: '/api/ai/completions' // Add AI completion endpoint
  };
  
  // Debug the save path
  console.log('Save path configured as:', window.editorConfig.savePath);
  console.log('Can edit:', window.editorConfig.canEdit);
</script>

<!-- Enhanced Editor JavaScript with AI Completion -->
<script type="module">
  import { createConsumer } from 'https://ga.jspm.io/npm:@rails/actioncable@8.0.200/app/assets/javascripts/actioncable.esm.js';
  
  window.ActionCable = { createConsumer };
  
  initializeEditor();
  
  function initializeEditor() {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', loadMonaco);
    } else {
      loadMonaco();
    }
  }
  
  function loadMonaco() {
    require.config({ 
      paths: { 
        vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs' 
      }
    });
    
    require(['vs/editor/editor.main'], function() {
      window.collaborativeEditor = new CollaborativeEditorWithAI(window.editorConfig);
      setupGlobalHandlers();
    });
  }
  
  function setupGlobalHandlers() {
    // Message input handlers
    const messageInput = document.getElementById('messageInput');
    const messageLength = document.getElementById('messageLength');
    
    messageInput.addEventListener('input', function() {
      messageLength.textContent = this.value.length;
      window.collaborativeEditor.handleTyping();
    });
    
    messageInput.addEventListener('keypress', function(e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });
    
    // Keyboard shortcuts
    document.addEventListener('keydown', function(e) {
      if (e.ctrlKey && e.key === 's') {
        e.preventDefault();
        document.getElementById('saveBtn')?.click();
      }
      
      if (e.ctrlKey && e.shiftKey && e.key === 'C') {
        e.preventDefault();
        toggleChatSidebar();
      }
      
      // AI Completion shortcuts
      if (e.ctrlKey && e.key === 'Enter') {
        e.preventDefault();
        window.collaborativeEditor?.triggerAICompletion();
      }
      
      if (e.ctrlKey && e.altKey && e.key === 'a') {
        e.preventDefault();
        toggleAICompletion();
      }
      
      // Handle AI popup navigation
      if (window.collaborativeEditor?.aiPopupVisible) {
        if (e.key === 'Escape') {
          e.preventDefault();
          window.collaborativeEditor.hideAICompletionPopup();
        } else if (e.key === 'Tab') {
          e.preventDefault();
          window.collaborativeEditor.acceptSelectedSuggestion();
        } else if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
          e.preventDefault();
          window.collaborativeEditor.navigateAISuggestions(e.key === 'ArrowUp' ? -1 : 1);
        }
      }
    });
  }

  class CollaborativeEditorWithAI {
    constructor(config) {
      this.config = config;
      this.editor = null;
      this.channel = null;
      this.users = new Map();
      this.messages = [];
      this.unreadMessages = 0;
      this.isChatOpen = false;
      this.hasUnsavedChanges = false;
      this.isTyping = false;
      this.typingTimeout = null;
      this.isRemoteUpdate = false;
      
      // AI Completion properties
      this.aiEnabled = true;
      this.aiSuggestions = [];
      this.aiPopupVisible = false;
      this.selectedSuggestionIndex = 0;
      this.aiCompletionTimeout = null;
      this.aiRequestInProgress = false;
      this.lastAIRequest = null;
      
      // Notification throttling
      this.lastNotificationTime = new Map();
      this.notificationCounts = new Map();
      
      this.initialize();
    }

    async initialize() {
      this.createEditor();
      this.setupChannel();
      this.setupUIHandlers();
      this.setupAICompletion();
      this.updateUI();
    }

    createEditor() {
      const editorElement = document.getElementById('monaco-editor');
      
      this.editor = monaco.editor.create(editorElement, {
        value: this.config.initialContent || '',
        language: this.config.language || 'javascript',
        theme: 'vs', // Light theme to match your layout
        automaticLayout: true,
        fontSize: 14,
        minimap: { enabled: true },
        wordWrap: 'on',
        readOnly: !this.config.canEdit,
        lineNumbers: 'on',
        renderWhitespace: 'boundary',
        scrollBeyondLastLine: false,
        smoothScrolling: true,
        cursorBlinking: 'smooth',
        // AI completion settings
        quickSuggestions: false, // Disable built-in suggestions to use our AI
        suggestOnTriggerCharacters: false,
        acceptSuggestionOnEnter: 'off'
      });

      this.setupEditorHandlers();
    }

    setupEditorHandlers() {
      this.editor.onDidChangeModelContent((e) => {
        if (this.isRemoteUpdate) return;
        
        this.hasUnsavedChanges = true;
        this.updateLastSaved('Unsaved changes');
        
        const content = this.editor.getValue();
        const changes = this.detectChanges(e);
        
        // Hide AI popup when content changes
        this.hideAICompletionPopup();
        
        clearTimeout(this.updateTimeout);
        this.updateTimeout = setTimeout(() => {
          this.sendContentUpdate(content, changes);
        }, 300);
        
        // Schedule AI completion if enabled
        if (this.aiEnabled && this.config.canEdit) {
          this.scheduleAICompletion();
        }
      });

      this.editor.onDidChangeCursorPosition((e) => {
        this.updateCursorPosition(e.position);
        
        // Hide AI popup when cursor moves
        this.hideAICompletionPopup();
        
        if (!this.isRemoteUpdate) {
          clearTimeout(this.cursorTimeout);
          this.cursorTimeout = setTimeout(() => {
            this.sendCursorUpdate(e.position);
          }, 100);
        }
      });

      this.editor.onDidChangeCursorSelection((e) => {
        this.updateSelectionInfo(e.selection);
        
        if (!this.isRemoteUpdate && !e.selection.isEmpty()) {
          this.sendSelectionUpdate(e.selection);
        }
      });
    }

    setupAICompletion() {
      // Initialize AI status
      this.updateAIStatus('ready', 'AI Ready');
      
      // Add click handler for AI completion button
      document.getElementById('aiCompletionBtn')?.addEventListener('click', () => {
        this.triggerAICompletion();
      });
    }

    scheduleAICompletion() {
      // Clear existing timeout
      clearTimeout(this.aiCompletionTimeout);
      
      // Schedule AI completion after 2 seconds of no typing
      this.aiCompletionTimeout = setTimeout(() => {
        if (this.aiEnabled && !this.aiRequestInProgress) {
          this.triggerAICompletion();
        }
      }, 2000);
    }

    async triggerAICompletion() {
      if (!this.aiEnabled || this.aiRequestInProgress || !this.config.canEdit) {
        return;
      }

      const position = this.editor.getPosition();
      const content = this.editor.getValue();
      
      // Don't trigger on empty content or if cursor is at start
      if (!content.trim() || (position.lineNumber === 1 && position.column === 1)) {
        return;
      }

      this.aiRequestInProgress = true;
      this.updateAIStatus('loading', 'Getting AI suggestions...');

      try {
        const suggestions = await this.getAISuggestions(content, position);
        
        if (suggestions && suggestions.length > 0) {
          this.showAICompletionPopup(suggestions, position);
          this.updateAIStatus('ready', `${suggestions.length} suggestions`);
        } else {
          this.updateAIStatus('ready', 'No suggestions');
          setTimeout(() => this.updateAIStatus('ready', 'AI Ready'), 2000);
        }
      } catch (error) {
        console.error('AI completion error:', error);
        this.updateAIStatus('error', 'AI Error');
        this.showNotification('Failed to get AI suggestions: ' + error.message, 'warning');
        setTimeout(() => this.updateAIStatus('ready', 'AI Ready'), 3000);
      } finally {
        this.aiRequestInProgress = false;
      }
    }

    async getAISuggestions(content, position) {
      const requestPayload = {
        project_id: this.config.projectId,
        content: content,
        cursor_position: {
          line: position.lineNumber,
          column: position.column
        },
        language: this.config.language,
        max_suggestions: 5,
        file_path: this.config.fileId
      };

      const response = await fetch('/api/ai/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': document.querySelector('[name="csrf-token"]').getAttribute('content')
        },
        body: JSON.stringify(requestPayload)
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();
      
      if (data.status === 'success' && data.completions) {
        return data.completions.map((completion, index) => ({
          id: index,
          text: completion.text,
          confidence: completion.confidence || 0.8,
          type: completion.type || 'suggestion',
          description: completion.description || 'AI suggestion'
        }));
      } else {
        throw new Error(data.message || 'Invalid response format');
      }
    }

    showAICompletionPopup(suggestions, position) {
      this.aiSuggestions = suggestions;
      this.selectedSuggestionIndex = 0;
      this.aiPopupVisible = true;

      const popup = document.getElementById('aiCompletionPopup');
      const suggestionsList = document.getElementById('aiSuggestionsList');

      // Clear previous suggestions
      suggestionsList.innerHTML = '';

      // Populate suggestions
      suggestions.forEach((suggestion, index) => {
        const suggestionElement = document.createElement('div');
        suggestionElement.className = `ai-suggestion-item ${index === 0 ? 'selected' : ''}`;
        suggestionElement.setAttribute('data-index', index);
        
        const confidenceColor = this.getConfidenceColor(suggestion.confidence);
        const confidencePercentage = Math.round(suggestion.confidence * 100);
        
        suggestionElement.innerHTML = `
          <div class="suggestion-content">
            <div class="suggestion-text">${this.escapeHtml(suggestion.text)}</div>
            <div class="suggestion-meta">
              <span class="suggestion-type">${suggestion.type}</span>
              <span class="suggestion-confidence" style="color: ${confidenceColor}">
                ${confidencePercentage}%
              </span>
            </div>
          </div>
        `;

        suggestionElement.addEventListener('click', () => {
          this.selectSuggestion(index);
          this.acceptSelectedSuggestion();
        });

        suggestionElement.addEventListener('mouseenter', () => {
          this.selectSuggestion(index);
        });

        suggestionsList.appendChild(suggestionElement);
      });

      // Position popup near cursor
      this.positionAIPopup(position);
      
      // Show popup
      popup.style.display = 'block';
      popup.classList.add('fade-in');
    }

    positionAIPopup(position) {
      const popup = document.getElementById('aiCompletionPopup');
      const editorElement = document.getElementById('monaco-editor');
      
      // Get cursor coordinates in editor
      const cursorCoords = this.editor.getScrolledVisiblePosition(position);
      
      if (cursorCoords) {
        const editorRect = editorElement.getBoundingClientRect();
        
        let left = editorRect.left + cursorCoords.left + 10;
        let top = editorRect.top + cursorCoords.top + 25;
        
        // Ensure popup doesn't go off-screen
        const popupRect = popup.getBoundingClientRect();
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        
        if (left + popupRect.width > windowWidth) {
          left = windowWidth - popupRect.width - 20;
        }
        
        if (top + popupRect.height > windowHeight) {
          top = editorRect.top + cursorCoords.top - popupRect.height - 10;
        }
        
        popup.style.left = `${left}px`;
        popup.style.top = `${top}px`;
      }
    }

    selectSuggestion(index) {
      if (index < 0 || index >= this.aiSuggestions.length) return;
      
      // Remove previous selection
      const previousSelected = document.querySelector('.ai-suggestion-item.selected');
      if (previousSelected) {
        previousSelected.classList.remove('selected');
      }
      
      // Add new selection
      const newSelected = document.querySelector(`[data-index="${index}"]`);
      if (newSelected) {
        newSelected.classList.add('selected');
        newSelected.scrollIntoView({ block: 'nearest' });
      }
      
      this.selectedSuggestionIndex = index;
    }

    navigateAISuggestions(direction) {
      if (!this.aiPopupVisible || this.aiSuggestions.length === 0) return;
      
      let newIndex = this.selectedSuggestionIndex + direction;
      
      if (newIndex < 0) {
        newIndex = this.aiSuggestions.length - 1;
      } else if (newIndex >= this.aiSuggestions.length) {
        newIndex = 0;
      }
      
      this.selectSuggestion(newIndex);
    }

    acceptSelectedSuggestion() {
      if (!this.aiPopupVisible || this.selectedSuggestionIndex < 0 || 
          this.selectedSuggestionIndex >= this.aiSuggestions.length) {
        return;
      }

      const suggestion = this.aiSuggestions[this.selectedSuggestionIndex];
      const position = this.editor.getPosition();
      
      // Insert the suggestion at current cursor position
      this.editor.executeEdits('ai-completion', [{
        range: new monaco.Range(position.lineNumber, position.column, position.lineNumber, position.column),
        text: suggestion.text,
        forceMoveMarkers: true
      }]);

      // Move cursor to end of inserted text
      const lines = suggestion.text.split('\n');
      const lastLine = lines[lines.length - 1];
      const newPosition = new monaco.Position(
        position.lineNumber + lines.length - 1,
        lines.length === 1 ? position.column + lastLine.length : lastLine.length + 1
      );
      
      this.editor.setPosition(newPosition);
      this.editor.focus();

      this.hideAICompletionPopup();
      this.showNotification(`AI suggestion applied (${Math.round(suggestion.confidence * 100)}% confidence)`, 'success', 2000);
      
      // Record feedback (could be sent to AI service for learning)
      this.recordAIFeedback(suggestion, 'accepted');
    }

    hideAICompletionPopup() {
      const popup = document.getElementById('aiCompletionPopup');
      popup.style.display = 'none';
      popup.classList.remove('fade-in');
      this.aiPopupVisible = false;
      this.aiSuggestions = [];
      this.selectedSuggestionIndex = 0;
    }

    updateAIStatus(status, message) {
      const statusIndicator = document.getElementById('aiStatusIndicator');
      const statusText = document.getElementById('aiStatusText');
      const statusMessage = document.getElementById('aiStatusMessage');
      
      // Update status indicator
      statusIndicator.className = 'ai-status-indicator';
      
      switch (status) {
        case 'ready':
          statusIndicator.classList.add('ready');
          break;
        case 'loading':
          statusIndicator.classList.add('loading');
          break;
        case 'error':
          statusIndicator.classList.add('error');
          break;
      }
      
      // Update status text
      if (statusText) statusText.textContent = message;
      if (statusMessage) statusMessage.textContent = message;
    }

    recordAIFeedback(suggestion, action) {
      // This could be enhanced to send feedback to your AI service
      console.log('AI Feedback:', {
        suggestion: suggestion,
        action: action,
        timestamp: new Date().toISOString()
      });
    }

    getConfidenceColor(confidence) {
      if (confidence >= 0.8) return '#198754'; // green
      if (confidence >= 0.6) return '#fd7e14'; // orange
      return '#dc3545'; // red
    }

    // All the existing collaborative editor methods continue here...
    // (keeping the rest of your original CollaborativeEditor class)
    
    setupChannel() {
      window.App = window.App || {};
      window.App.cable = window.ActionCable.createConsumer();

      this.channel = window.App.cable.subscriptions.create(
        {
          channel: 'EditorChannel',
          project_id: this.config.projectId,
          file_id: this.config.fileId,
          branch: this.config.branch
        },
        {
          connected: () => {
            console.log('Connected to editor channel');
            this.updateConnectionStatus('connected');
            this.showNotification('Connected to collaborative session', 'success');
          },

          disconnected: () => {
            console.log('Disconnected from editor channel');
            this.updateConnectionStatus('disconnected');
            this.showNotification('Disconnected from collaborative session', 'warning');
          },

          received: (data) => {
            console.log('Received message:', data.type, data);
            this.handleMessage(data);
          },

          error: (error) => {
            console.error('ActionCable error:', error);
          }
        }
      );
    }

    setupUIHandlers() {
      document.getElementById('saveBtn')?.addEventListener('click', () => {
        this.saveFile();
      });

      document.getElementById('commitBtn')?.addEventListener('click', () => {
        this.commitFile();
      });
    }

    handleMessage(data) {
      // Filter out own messages for certain types
      if (data.sender_id === this.config.userId && 
          !['initial_state', 'fresh_state', 'conflict_detected', 'message_received', 'conflict_resolution'].includes(data.type)) {
        return;
      }
      
      switch (data.type) {
        case 'initial_state':
          this.handleInitialState(data);
          break;
        case 'user_joined':
          this.handleUserJoined(data);
          break;
        case 'user_left':
          this.handleUserLeft(data);
          break;
        case 'content_update':
          this.handleContentUpdate(data);
          break;
        case 'message_received':
          this.handleMessageReceived(data);
          break;
        case 'typing_indicator':
          this.handleTypingIndicator(data);
          break;
        case 'conflict_detected':
          this.handleConflictDetected(data);
          break;
        case 'conflict_resolution':
          this.handleConflictResolution(data);
          break;
        case 'fresh_state':
          this.handleFreshState(data);
          break;
      }
    }

    handleInitialState(data) {
      console.log('Handling initial state:', data);
      
      if (data.content && data.content !== this.editor.getValue()) {
        this.isRemoteUpdate = true;
        this.editor.setValue(data.content);
        this.isRemoteUpdate = false;
      }
      
      if (data.users) {
        this.users.clear();
        data.users.forEach(user => {
          if (user.id !== this.config.userId) {
            this.users.set(user.id, user);
          }
        });
      }
      
      if (data.recent_messages) {
        const messagesContainer = document.getElementById('chatMessages');
        messagesContainer.innerHTML = '';
        
        data.recent_messages.forEach(msg => {
          this.addMessage(msg, false);
        });
        
        if (data.recent_messages.length === 0) {
          this.showWelcomeMessage();
        }
      } else {
        this.showWelcomeMessage();
      }
      
      this.updateUsersList();
    }

    handleUserJoined(data) {
      this.users.set(data.user.id, data.user);
      this.updateUsersList();
      this.showSmartNotification(`${data.user.name} joined the session`, 'info', 'user_activity');
    }

    handleUserLeft(data) {
      const user = this.users.get(data.user_id);
      if (user) {
        this.users.delete(data.user_id);
        this.updateUsersList();
        this.showSmartNotification(`${user.name} left the session`, 'info', 'user_activity');
      }
    }

    handleContentUpdate(data) {
      this.isRemoteUpdate = true;
      this.editor.setValue(data.content);
      this.isRemoteUpdate = false;
      
      const user = this.users.get(data.user_id);
      if (user && this.shouldShowContentNotification()) {
        this.showSmartNotification(`${user.name} updated the file`, 'info', 'content_update', true);
      }
    }

    handleMessageReceived(data) {
      this.addMessage(data);
      
      if (!this.isChatOpen) {
        this.unreadMessages++;
        this.updateChatBadge();
        this.showSmartNotification(`💬 ${data.user_name}: ${this.truncateMessage(data.message)}`, 'info', 'message');
      }
    }

    handleTypingIndicator(data) {
      const indicator = document.getElementById('typingIndicator');
      const user = this.users.get(data.user_id);
      
      if (data.is_typing && user) {
        indicator.innerHTML = `
          <div class="typing-animation d-flex align-items-center">
            <div class="typing-dots me-2">
              <span></span>
              <span></span>
              <span></span>
            </div>
            <small class="text-muted">${user.name} is typing...</small>
          </div>
        `;
      } else {
        indicator.innerHTML = '';
      }
    }

    handleConflictDetected(data) {
      const user = this.users.get(data.conflicting_user_id);
      const userName = user ? user.name : 'Another user';
      
      this.showNotification(`⚠️ Edit conflict with ${userName} on lines ${data.lines.join(', ')}`, 'warning');
      this.showConflictModal(data);
    }

    handleConflictResolution(data) {
      console.log('Conflict resolution received:', data);
      
      switch (data.action) {
        case 'accepted':
          if (data.content && data.content !== this.editor.getValue()) {
            this.isRemoteUpdate = true;
            this.editor.setValue(data.content);
            this.isRemoteUpdate = false;
          }
          this.showNotification('Conflict resolved - content updated', 'success');
          break;
        case 'ignored':
          if (data.content && data.content !== this.editor.getValue()) {
            this.isRemoteUpdate = true;
            this.editor.setValue(data.content);
            this.isRemoteUpdate = false;
          }
          this.showNotification('Conflict ignored - content restored', 'success');
          break;
        case 'error':
          this.showNotification(`Conflict resolution error: ${data.message}`, 'danger');
          break;
      }
    }

    handleFreshState(data) {
      console.log('Fresh state received:', data);
      
      if (data.content && data.content !== this.editor.getValue()) {
        this.isRemoteUpdate = true;
        this.editor.setValue(data.content);
        this.isRemoteUpdate = false;
      }
      
      if (data.users) {
        this.users.clear();
        data.users.forEach(user => {
          if (user.id !== this.config.userId) {
            this.users.set(user.id, user);
          }
        });
        this.updateUsersList();
      }
      
      this.showNotification('Editor refreshed with latest content', 'success');
    }

    // Message handling
    sendMessage() {
      const input = document.getElementById('messageInput');
      const message = input.value.trim();
      
      if (!message) return;
      
      if (this.channel) {
        this.channel.perform('send_message', { message });
      }
      
      input.value = '';
      document.getElementById('messageLength').textContent = '0';
      this.stopTyping();
    }

    addMessage(data, animate = true) {
      const messagesContainer = document.getElementById('chatMessages');
      
      const welcomeMessage = messagesContainer.querySelector('.welcome-message');
      if (welcomeMessage) {
        welcomeMessage.remove();
      }
      
      const messageElement = document.createElement('div');
      const isOwnMessage = data.user_id === this.config.userId;
      
      messageElement.className = `message ${isOwnMessage ? 'own-message' : 'other-message'} mb-3`;
      
      let time;
      if (typeof data.timestamp === 'number') {
        time = new Date(data.timestamp * 1000).toLocaleTimeString([], { 
          hour: '2-digit', 
          minute: '2-digit' 
        });
      } else {
        time = new Date(data.timestamp).toLocaleTimeString([], { 
          hour: '2-digit', 
          minute: '2-digit' 
        });
      }
      
      messageElement.innerHTML = `
        <div class="d-flex ${isOwnMessage ? 'justify-content-end' : 'justify-content-start'}">
          <div class="message-content">
            <div class="message-header d-flex justify-content-between align-items-center mb-1">
              <span class="message-author fw-semibold">${this.escapeHtml(data.user_name)}</span>
              <span class="message-time text-muted small">${time}</span>
            </div>
            <div class="message-text">${this.formatMessageText(data.message)}</div>
          </div>
        </div>
      `;
      
      messagesContainer.appendChild(messageElement);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
      
      if (animate) {
        messageElement.style.opacity = '0';
        messageElement.style.transform = 'translateY(10px)';
        setTimeout(() => {
          messageElement.style.transition = 'all 0.3s ease';
          messageElement.style.opacity = '1';
          messageElement.style.transform = 'translateY(0)';
        }, 10);
      }
      
      this.messages.push(data);
    }

    showWelcomeMessage() {
      const messagesContainer = document.getElementById('chatMessages');
      messagesContainer.innerHTML = `
        <div class="welcome-message">
          <div class="text-center text-muted py-4">
            <i class="bi bi-chat-heart fs-3 mb-2 d-block"></i>
            <p class="mb-0">Welcome to team chat!</p>
            <small>Start collaborating with your team members</small>
          </div>
        </div>
      `;
    }

    handleTyping() {
      if (!this.isTyping) {
        this.isTyping = true;
        if (this.channel) {
          this.channel.perform('typing_indicator', { is_typing: true });
        }
      }
      
      clearTimeout(this.typingTimeout);
      this.typingTimeout = setTimeout(() => {
        this.stopTyping();
      }, 1000);
    }

    stopTyping() {
      if (this.isTyping) {
        this.isTyping = false;
        if (this.channel) {
          this.channel.perform('typing_indicator', { is_typing: false });
        }
      }
    }

    // UI Updates
    updateUsersList() {
      const container = document.getElementById('activeUsers');
      const chatContainer = document.getElementById('chatUsersList');
      const onlineCount = document.getElementById('onlineCount');
      
      const otherUsers = Array.from(this.users.values());
      const userElements = otherUsers.map(user => `
        <div class="user-avatar" 
             style="background-color: ${user.color}" 
             title="${user.name}">
          ${user.name.substring(0, 2).toUpperCase()}
        </div>
      `).join('');
      
      if (container) {
        container.innerHTML = userElements;
      }
      
      if (chatContainer) {
        const currentUserElement = `
          <div class="chat-user-item current-user">
            <div class="user-avatar-small bg-primary">
              ${this.config.userName.substring(0, 1).toUpperCase()}
            </div>
            <span class="user-name">${this.escapeHtml(this.config.userName)} (You)</span>
            <div class="user-status online"></div>
          </div>
        `;
        
        const chatUserElements = otherUsers.map(user => `
          <div class="chat-user-item">
            <div class="user-avatar-small" style="background-color: ${user.color}">
              ${user.name.substring(0, 1).toUpperCase()}
            </div>
            <span class="user-name">${this.escapeHtml(user.name)}</span>
            <div class="user-status online"></div>
          </div>
        `).join('');
        
        chatContainer.innerHTML = currentUserElement + chatUserElements;
      }
      
      if (onlineCount) {
        onlineCount.textContent = this.users.size + 1;
      }
    }

    updateChatBadge() {
      const badge = document.getElementById('chatNotificationBadge');
      
      if (this.unreadMessages > 0) {
        badge.textContent = this.unreadMessages > 99 ? '99+' : this.unreadMessages;
        badge.style.display = 'inline';
      } else {
        badge.style.display = 'none';
      }
    }

    updateConnectionStatus(status) {
      const statusElement = document.getElementById('connectionStatus');
      
      switch (status) {
        case 'connected':
          statusElement.innerHTML = '<i class="bi bi-circle-fill text-success me-1"></i><small class="text-muted">Connected</small>';
          break;
        case 'connecting':
          statusElement.innerHTML = '<i class="bi bi-circle-fill text-warning me-1"></i><small class="text-muted">Connecting...</small>';
          break;
        case 'disconnected':
          statusElement.innerHTML = '<i class="bi bi-circle-fill text-danger me-1"></i><small class="text-muted">Disconnected</small>';
          break;
      }
    }

    updateCursorPosition(position) {
      const element = document.getElementById('cursorPosition');
      if (element) {
        element.textContent = `Line ${position.lineNumber}, Col ${position.column}`;
      }
    }

    updateSelectionInfo(selection) {
      const element = document.getElementById('selectionInfo');
      
      if (selection.isEmpty()) {
        element.style.display = 'none';
      } else {
        const selectedText = this.editor.getModel().getValueInRange(selection);
        element.textContent = `Selected: ${selectedText.length} chars`;
        element.style.display = 'inline';
      }
    }

    updateLastSaved(text) {
      const element = document.getElementById('lastSaved');
      if (element) {
        element.textContent = text;
        
        if (text === 'Unsaved changes') {
          element.classList.add('text-warning');
          element.classList.remove('text-success');
        } else {
          element.classList.remove('text-warning');
          element.classList.add('text-success');
        }
      }
    }

    updateUI() {
      const fileNameEl = document.getElementById('fileName');
      const branchNameEl = document.getElementById('branchName');
      const languageModeEl = document.getElementById('languageMode');
      const editorModeEl = document.getElementById('editorMode');
      const saveBtnEl = document.getElementById('saveBtn');
      const commitBtnEl = document.getElementById('commitBtn');
      
      if (fileNameEl) fileNameEl.textContent = this.config.fileName || 'Unknown file';
      if (branchNameEl) branchNameEl.textContent = this.config.branch || 'main';
      if (languageModeEl) languageModeEl.innerHTML = `<i class="bi bi-code-slash me-1"></i>${this.config.language || 'text'}`;
      
      if (!this.config.canEdit) {
        if (editorModeEl) editorModeEl.innerHTML = '<i class="bi bi-eye me-1"></i>Read Only';
        if (saveBtnEl) saveBtnEl.disabled = true;
        if (commitBtnEl) commitBtnEl.disabled = true;
      }
    }

    // File operations
    async saveFile() {
      const btn = document.getElementById('saveBtn');
      const originalText = btn.innerHTML;
      
      btn.disabled = true;
      btn.innerHTML = '<i class="bi bi-arrow-repeat spin me-1"></i>Saving...';
      
      try {
        const content = this.editor.getValue();
        
        const response = await fetch(this.config.savePath, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            'X-CSRF-Token': document.querySelector('[name="csrf-token"]').getAttribute('content'),
            'Accept': 'application/json'
          },
          body: new URLSearchParams({
            content: content,
            path: this.config.currentPath
          })
        });
        
        if (!response.ok) {
          const responseText = await response.text();
          throw new Error(`HTTP ${response.status}: ${responseText.substring(0, 100)}`);
        }
        
        const result = await response.json();
        
        if (result.status === 'success') {
          this.hasUnsavedChanges = false;
          this.updateLastSaved(`Saved at ${new Date().toLocaleTimeString()}`);
          this.showNotification('File saved successfully', 'success');
        } else {
          throw new Error(result.message || 'Save failed');
        }
      } catch (error) {
        console.error('Save error:', error);
        this.showNotification(`Failed to save file: ${error.message}`, 'danger');
      } finally {
        btn.disabled = !this.config.canEdit;
        btn.innerHTML = originalText;
      }
    }

    async commitFile() {
      const message = prompt('Enter commit message:');
      if (!message) return;
      
      const btn = document.getElementById('commitBtn');
      const originalText = btn.innerHTML;
      
      btn.disabled = true;
      btn.innerHTML = '<i class="bi bi-arrow-repeat spin me-1"></i>Committing...';
      
      try {
        const response = await fetch(this.config.commitPath, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            'X-CSRF-Token': document.querySelector('[name="csrf-token"]').getAttribute('content')
          },
          body: new URLSearchParams({
            message: message,
            path: this.config.currentPath
          })
        });
        
        const result = await response.json();
        
        if (result.status === 'success') {
          this.showNotification('Changes committed successfully', 'success');
          this.hasUnsavedChanges = false;
          this.updateLastSaved('Committed');
        } else {
          throw new Error(result.message || 'Commit failed');
        }
      } catch (error) {
        this.showNotification(`Failed to commit changes: ${error.message}`, 'danger');
      } finally {
        btn.disabled = !this.config.canEdit;
        btn.innerHTML = originalText;
      }
    }

    // Notification system
    showSmartNotification(message, type = 'info', category = 'general', throttled = false) {
      if (throttled && this.shouldThrottleNotification(category)) {
        return;
      }
      
      this.showNotification(message, type);
    }

    shouldThrottleNotification(category) {
      const now = Date.now();
      const count = this.notificationCounts.get(category) || 0;
      const lastTime = this.lastNotificationTime.get(category) || 0;
      
      if (count >= 3 && (now - lastTime) < 60000) {
        return true;
      }
      
      if ((now - lastTime) < 3000) {
        return true;
      }
      
      this.notificationCounts.set(category, count + 1);
      this.lastNotificationTime.set(category, now);
      return false;
    }

    shouldShowContentNotification() {
      const now = Date.now();
      const lastContentNotification = this.lastNotificationTime.get('content_update') || 0;
      return (now - lastContentNotification) > 10000;
    }

    showNotification(message, type = 'info', duration = 4000) {
      const container = document.getElementById('notifications');
      const toast = document.createElement('div');
      
      const alertClass = type === 'error' ? 'danger' : type;
      toast.className = `alert alert-${alertClass} alert-dismissible fade show`;
      
      const icon = this.getIconForType(type);
      toast.innerHTML = `
        <div class="d-flex align-items-center">
          <i class="bi bi-${icon} me-2"></i>
          <span>${message}</span>
        </div>
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
      `;
      
      container.appendChild(toast);
      
      if (duration > 0) {
        setTimeout(() => {
          if (toast.parentNode) {
            toast.classList.remove('show');
            setTimeout(() => toast.remove(), 150);
          }
        }, duration);
      }
    }

    showConflictModal(data) {
      const modal = document.getElementById('conflictModal');
      const body = document.getElementById('conflictModalBody');
      
      const user = this.users.get(data.conflicting_user_id);
      const userName = user ? user.name : 'Another user';
      
      body.innerHTML = `
        <div class="alert alert-warning">
          <i class="bi bi-exclamation-triangle me-2"></i>
          <strong>Edit Conflict Detected</strong>
        </div>
        <p class="mb-3">
          <strong>${userName}</strong> edited lines <strong>${data.lines.join(', ')}</strong> 
          that you were working on. This might cause conflicts in your changes.
        </p>
        <div class="d-grid gap-2">
          <button class="btn btn-primary" onclick="window.collaborativeEditor.resolveConflict('accept', '${data.conflict_id}')">
            <i class="bi bi-download me-2"></i>
            Accept their changes (recommended)
          </button>
          <button class="btn btn-outline-secondary" onclick="window.collaborativeEditor.resolveConflict('ignore', '${data.conflict_id}')">
            <i class="bi bi-x-circle me-2"></i>
            Keep my version
          </button>
          <button class="btn btn-outline-info" onclick="window.collaborativeEditor.refreshEditor(); closeConflictModal();">
            <i class="bi bi-arrow-clockwise me-2"></i>
            Refresh to see latest
          </button>
        </div>
      `;

      const bsModal = new bootstrap.Modal(modal, {
        backdrop: false,
        keyboard: false
      });
      bsModal.show();
    }

    resolveConflict(action, conflictId) {
      console.log('Resolving conflict with action:', action, 'conflictId:', conflictId);
      
      if (!this.channel || !this.channel.perform) {
        console.error('Channel not available for conflict resolution');
        return;
      }
      
      try {
        const payload = {
          conflict_id: String(conflictId),
          resolution_action: action
        };
        
        if (action === 'ignore') {
          payload.user_content = this.editor.getValue();
        }
        
        this.channel.perform('resolve_conflict', payload);
        
      } catch (error) {
        console.error('Error sending conflict resolution:', error);
        this.showNotification('Failed to resolve conflict', 'danger');
        return;
      }
      
      this.showNotification(
        action === 'accept' ? 'Accepting their changes...' : 'Keeping your version...',
        'info'
      );
      
      closeConflictModal();
    }

    refreshEditor() {
      if (this.channel) {
        this.channel.perform('request_fresh_state', {});
        this.showNotification('Refreshing editor content...', 'info');
      }
    }

    // Utility methods
    detectChanges(event) {
      const changes = event.changes;
      const affectedLines = new Set();
      
      changes.forEach(change => {
        const startLine = change.range.startLineNumber;
        const endLine = change.range.endLineNumber;
        
        for (let i = startLine; i <= endLine; i++) {
          affectedLines.add(i);
        }
      });
      
      return {
        lines: Array.from(affectedLines),
        timestamp: Date.now()
      };
    }

    sendContentUpdate(content, changes) {
      if (this.channel) {
        this.channel.perform('content_update', {
          content: content,
          changes: changes
        });
      }
    }

    sendCursorUpdate(position) {
      if (this.channel) {
        this.channel.perform('cursor_update', {
          line: position.lineNumber,
          column: position.column
        });
      }
    }

    sendSelectionUpdate(selection) {
      if (this.channel) {
        this.channel.perform('selection_update', {
          start_line: selection.startLineNumber,
          start_column: selection.startColumn,
          end_line: selection.endLineNumber,
          end_column: selection.endColumn
        });
      }
    }

    formatMessageText(text) {
      return this.escapeHtml(text)
        .replace(/:\)/g, '😊')
        .replace(/:\(/g, '😢')
        .replace(/:D/g, '😃')
        .replace(/;\)/g, '😉')
        .replace(/<3/g, '❤️');
    }

    truncateMessage(message, length = 50) {
      return message.length > length ? message.substring(0, length) + '...' : message;
    }

    escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    getIconForType(type) {
      const icons = {
        'success': 'check-circle-fill',
        'info': 'info-circle-fill',
        'warning': 'exclamation-triangle-fill',
        'danger': 'exclamation-circle-fill',
        'error': 'exclamation-circle-fill'
      };
      return icons[type] || 'info-circle-fill';
    }
  }

  // Global functions for UI interactions
  window.toggleChatSidebar = function() {
    const sidebar = document.getElementById('chatSidebar');
    const editorContainer = document.getElementById('editorContainer');
    const toggleBtn = document.getElementById('chatToggleBtn');
    const isOpen = sidebar.classList.contains('open');
    
    if (isOpen) {
      sidebar.classList.remove('open');
      editorContainer.classList.remove('chat-open');
      toggleBtn.classList.remove('active');
      if (window.collaborativeEditor) {
        window.collaborativeEditor.isChatOpen = false;
      }
    } else {
      sidebar.classList.add('open');
      editorContainer.classList.add('chat-open');
      toggleBtn.classList.add('active');
      if (window.collaborativeEditor) {
        window.collaborativeEditor.isChatOpen = true;
        window.collaborativeEditor.unreadMessages = 0;
        window.collaborativeEditor.updateChatBadge();
        
        setTimeout(() => {
          document.getElementById('messageInput')?.focus();
        }, 300);
      }
    }
  };

  window.toggleAICompletion = function() {
    if (!window.collaborativeEditor) return;
    
    window.collaborativeEditor.aiEnabled = !window.collaborativeEditor.aiEnabled;
    const btn = document.getElementById('aiToggleBtn');
    const statusText = document.getElementById('aiStatusText');
    
    if (window.collaborativeEditor.aiEnabled) {
      btn.classList.add('active');
      btn.title = 'AI Completion Enabled (Ctrl+Alt+A to disable)';
      window.collaborativeEditor.updateAIStatus('ready', 'AI Ready');
      window.collaborativeEditor.showNotification('AI completion enabled', 'success');
    } else {
      btn.classList.remove('active');
      btn.title = 'AI Completion Disabled (Ctrl+Alt+A to enable)';
      window.collaborativeEditor.hideAICompletionPopup();
      window.collaborativeEditor.updateAIStatus('ready', 'AI Disabled');
      window.collaborativeEditor.showNotification('AI completion disabled', 'info');
    }
  };

  window.triggerAICompletion = function() {
    if (window.collaborativeEditor) {
      window.collaborativeEditor.triggerAICompletion();
    }
  };

  window.hideAICompletionPopup = function() {
    if (window.collaborativeEditor) {
      window.collaborativeEditor.hideAICompletionPopup();
    }
  };

  window.sendMessage = function() {
    if (window.collaborativeEditor) {
      window.collaborativeEditor.sendMessage();
    }
  };

  window.clearChatHistory = function() {
    if (confirm('Are you sure you want to clear the chat history? This action cannot be undone.')) {
      const messagesContainer = document.getElementById('chatMessages');
      
      if (window.collaborativeEditor) {
        window.collaborativeEditor.showWelcomeMessage();
        window.collaborativeEditor.messages = [];
        window.collaborativeEditor.showNotification('Chat history cleared locally', 'info');
      } else {
        messagesContainer.innerHTML = `
          <div class="welcome-message">
            <div class="text-center text-muted py-4">
              <i class="bi bi-chat-heart fs-3 mb-2 d-block"></i>
              <p class="mb-0">Chat history cleared</p>
              <small>Start a new conversation with your team</small>
            </div>
          </div>
        `;
      }
    }
  };

  window.downloadFile = function() {
    if (!window.collaborativeEditor?.editor) {
      alert('Editor not ready yet. Please try again.');
      return;
    }
    
    const content = window.collaborativeEditor.editor.getValue();
    const fileName = window.editorConfig?.fileName || 'code.txt';
    
    const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    
    const link = document.createElement('a');
    link.href = url;
    link.download = fileName;
    link.style.display = 'none';
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    URL.revokeObjectURL(url);
    
    window.collaborativeEditor.showNotification(`Downloaded ${fileName}`, 'success');
  };

  window.refreshEditor = function() {
    if (window.collaborativeEditor?.channel) {
      window.collaborativeEditor.updateConnectionStatus('connecting');
      window.collaborativeEditor.channel.perform('request_fresh_state', {});
      window.collaborativeEditor.showNotification('Refreshing editor content...', 'info');
    }
  };

  window.closeConflictModal = function() {
    const modal = document.getElementById('conflictModal');
    const modalInstance = bootstrap.Modal.getInstance(modal);
    if (modalInstance) {
      modalInstance.hide();
    }
  };

  // Handle window beforeunload to warn about unsaved changes
  window.addEventListener('beforeunload', function(e) {
    if (window.collaborativeEditor?.hasUnsavedChanges) {
      e.preventDefault();
      e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
      return e.returnValue;
    }
  });

  // Handle visibility change to manage connection
  document.addEventListener('visibilitychange', function() {
    if (window.collaborativeEditor?.channel) {
      if (document.hidden) {
        console.log('Editor tab hidden');
      } else {
        console.log('Editor tab visible');
      }
    }
  });

</script>

<style>
  /* Complete CSS for the collaborative editor with AI completion */
  :root {
    --chat-width: 350px;
    --header-height: 60px;
    --status-height: 32px;
    --border-color: #dee2e6;
    --bg-light: #f8f9fa;
    --text-muted: #6c757d;
    --primary-color: #0d6efd;
    --success-color: #198754;
    --warning-color: #ffc107;
    --danger-color: #dc3545;
    --ai-primary: #20c997;
  }

  .editor-page-wrapper {
    position: relative;
    height: 100vh;
    background: var(--bg-light);
    overflow: hidden;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  }

  /* AI Toggle Button */
  .ai-toggle-btn {
    position: fixed;
    bottom: 90px;
    right: 20px;
    z-index: 1050;
    border-radius: 50%;
    width: 48px;
    height: 48px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    border: none;
    background: var(--ai-primary);
    color: white;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
  }

  .ai-toggle-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0,0,0,0.2);
    background: #1aa884;
  }

  .ai-toggle-btn.active {
    background: var(--success-color);
    animation: ai-pulse 2s infinite;
  }

  @keyframes ai-pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
  }

  .ai-status-indicator {
    position: absolute;
    top: -2px;
    right: -2px;
    width: 12px;
    height: 12px;
    border-radius: 50%;
    border: 2px solid white;
  }

  .ai-status-indicator.ready {
    background: var(--success-color);
  }

  .ai-status-indicator.loading {
    background: var(--warning-color);
    animation: loading-pulse 1s infinite;
  }

  .ai-status-indicator.error {
    background: var(--danger-color);
  }

  @keyframes loading-pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.2); }
  }

  /* Chat Toggle Button - moved to bottom right */
  .chat-toggle-btn-bottom {
    position: fixed;
    bottom: 20px;
    right: 20px;
    z-index: 1050;
    border-radius: 50%;
    width: 56px;
    height: 56px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    border: none;
    background: var(--primary-color);
    color: white;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
  }

  .chat-toggle-btn-bottom:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0,0,0,0.2);
    background: #0b5ed7;
  }

  .chat-toggle-btn-bottom:active {
    transform: translateY(0);
  }

  .chat-toggle-btn-bottom .chat-notification-badge {
    position: absolute;
    top: -2px;
    right: -2px;
    font-size: 0.7rem;
    min-width: 20px;
    height: 20px;
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    animation: pulse 2s infinite;
  }

  @keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
  }

  /* Editor Container */
  .editor-container {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    flex-direction: column;
    transition: right 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    background: white;
  }

  .editor-container.chat-open {
    right: var(--chat-width);
  }

  /* Editor Header */
  .editor-header {
    height: var(--header-height);
    background: white;
    border-bottom: 1px solid var(--border-color);
    padding: 0 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    z-index: 10;
    flex-shrink: 0;
  }

  .editor-info {
    display: flex;
    align-items: center;
    gap: 20px;
  }

  .file-name {
    font-size: 16px;
    font-weight: 600;
    color: #212529;
    display: flex;
    align-items: center;
  }

  .branch-badge {
    background: #e3f2fd;
    color: #1976d2;
    padding: 4px 12px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: 500;
    border: 1px solid #bbdefb;
  }

  .connection-status, .ai-status {
    display: flex;
    align-items: center;
  }

  .ai-status .bi-robot {
    color: var(--ai-primary);
  }

  .editor-actions {
    display: flex;
    gap: 20px;
    align-items: center;
  }

  .active-users {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .users-list {
    display: flex;
    gap: 4px;
  }

  .user-avatar {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 11px;
    font-weight: 600;
    color: white;
    border: 2px solid white;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    position: relative;
  }

  .user-avatar::after {
    content: '';
    position: absolute;
    bottom: -2px;
    right: -2px;
    width: 8px;
    height: 8px;
    background: var(--success-color);
    border: 2px solid white;
    border-radius: 50%;
  }

  .action-buttons {
    display: flex;
    gap: 8px;
    align-items: center;
  }

  /* Monaco Editor */
  .editor-main {
    flex: 1;
    position: relative;
    overflow: hidden;
  }

  #monaco-editor {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    border: none;
  }

  /* AI Completion Popup */
  .ai-completion-popup {
    position: fixed;
    background: white;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.2);
    z-index: 1000;
    min-width: 400px;
    max-width: 600px;
    max-height: 400px;
    overflow: hidden;
    font-size: 14px;
  }

  .ai-completion-popup.fade-in {
    animation: fadeInUp 0.2s ease-out;
  }

  @keyframes fadeInUp {
    from {
      opacity: 0;
      transform: translateY(10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .ai-popup-header {
    padding: 12px 16px;
    border-bottom: 1px solid var(--border-color);
    background: var(--bg-light);
    font-size: 13px;
  }

  .ai-suggestions-list {
    max-height: 300px;
    overflow-y: auto;
  }

  .ai-suggestion-item {
    padding: 12px 16px;
    border-bottom: 1px solid #f0f0f0;
    cursor: pointer;
    transition: background-color 0.15s ease;
  }

  .ai-suggestion-item:hover,
  .ai-suggestion-item.selected {
    background: #f8f9fa;
  }

  .ai-suggestion-item.selected {
    background: #e3f2fd;
    border-left: 3px solid var(--ai-primary);
  }

  .suggestion-content {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .suggestion-text {
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-size: 13px;
    line-height: 1.4;
    color: #2d3748;
    white-space: pre-wrap;
    background: #f7fafc;
    padding: 8px 12px;
    border-radius: 4px;
    border-left: 3px solid var(--ai-primary);
  }

  .suggestion-meta {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 12px;
  }

  .suggestion-type {
    background: #e2e8f0;
    color: #4a5568;
    padding: 2px 8px;
    border-radius: 12px;
    font-weight: 500;
  }

  .suggestion-confidence {
    font-weight: 600;
  }

  .ai-popup-footer {
    padding: 8px 16px;
    background: var(--bg-light);
    border-top: 1px solid var(--border-color);
    font-size: 11px;
    color: var(--text-muted);
  }

  /* Editor Status Bar */
  .editor-status-bar {
    height: var(--status-height);
    background: var(--bg-light);
    border-top: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 20px;
    font-size: 12px;
    color: var(--text-muted);
    flex-shrink: 0;
  }

  .status-left, .status-right {
    display: flex;
    gap: 15px;
  }

  .status-item {
    display: flex;
    align-items: center;
    gap: 4px;
    white-space: nowrap;
  }

  #aiCompletionStatus .bi-robot {
    color: var(--ai-primary);
  }

  /* Chat Sidebar */
  .chat-sidebar {
    position: fixed;
    top: 0;
    right: calc(var(--chat-width) * -1);
    width: var(--chat-width);
    height: 100vh;
    background: white;
    border-left: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    transition: right 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    z-index: 1040;
    box-shadow: -2px 0 20px rgba(0,0,0,0.1);
  }

  .chat-sidebar.open {
    right: 0;
  }

  /* Chat Header */
  .chat-header {
    padding: 16px;
    border-bottom: 1px solid var(--border-color);
    background: var(--bg-light);
    flex-shrink: 0;
  }

  /* Chat Users */
  .chat-users {
    border-bottom: 1px solid var(--border-color);
    background: var(--bg-light);
    flex-shrink: 0;
  }

  .chat-users-header {
    padding: 8px 16px 4px;
  }

  .chat-users-list {
    padding: 0 16px 12px;
    max-height: 120px;
    overflow-y: auto;
  }

  .chat-user-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 4px 0;
  }

  .chat-user-item.current-user {
    background: rgba(13, 110, 253, 0.1);
    border-radius: 6px;
    padding: 6px 4px;
    margin: 2px 0;
  }

  .chat-user-item.current-user .user-name {
    font-weight: 600;
    color: var(--primary-color);
  }

  .user-avatar-small {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 10px;
    font-weight: 600;
    color: white;
    flex-shrink: 0;
  }

  .user-name {
    flex: 1;
    font-size: 13px;
    color: #495057;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .user-status {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    flex-shrink: 0;
  }

  .user-status.online {
    background: var(--success-color);
    box-shadow: 0 0 4px rgba(25, 135, 84, 0.4);
  }

  /* Chat Messages */
  .chat-messages {
    flex: 1;
    overflow-y: auto;
    padding: 16px;
    scroll-behavior: smooth;
  }

  .welcome-message {
    text-align: center;
    color: var(--text-muted);
    margin: 20px 0;
  }

  .message {
    margin-bottom: 12px;
    animation: messageSlideIn 0.3s ease-out;
  }

  @keyframes messageSlideIn {
    from {
      opacity: 0;
      transform: translateY(10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .message-content {
    max-width: 85%;
    background: var(--bg-light);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 8px 12px;
    position: relative;
  }

  .message.own-message .message-content {
    background: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
  }

  .message.own-message .message-content::after {
    content: '';
    position: absolute;
    top: 10px;
    right: -6px;
    width: 0;
    height: 0;
    border: 6px solid transparent;
    border-left-color: var(--primary-color);
  }

  .message.other-message .message-content::after {
    content: '';
    position: absolute;
    top: 10px;
    left: -6px;
    width: 0;
    height: 0;
    border: 6px solid transparent;
    border-right-color: var(--bg-light);
  }

  .message-header {
    margin-bottom: 4px;
  }

  .message-author {
    font-size: 12px;
    color: var(--text-muted);
    font-weight: 600;
  }

  .message.own-message .message-author {
    color: rgba(255,255,255,0.8);
  }

  .message-time {
    font-size: 11px;
    opacity: 0.7;
  }

  .message-text {
    font-size: 14px;
    line-height: 1.4;
    word-wrap: break-word;
  }

  /* Typing Indicator */
  .typing-indicator {
    padding: 8px 16px;
    min-height: 32px;
    display: flex;
    align-items: center;
    border-top: 1px solid var(--border-color);
    background: var(--bg-light);
    flex-shrink: 0;
  }

  .typing-dots {
    display: flex;
    gap: 2px;
  }

  .typing-dots span {
    width: 4px;
    height: 4px;
    border-radius: 50%;
    background: var(--text-muted);
    animation: typing-pulse 1.4s infinite ease-in-out;
  }

  .typing-dots span:nth-child(1) { animation-delay: -0.32s; }
  .typing-dots span:nth-child(2) { animation-delay: -0.16s; }

  @keyframes typing-pulse {
    0%, 80%, 100% {
      transform: scale(0.8);
      opacity: 0.5;
    }
    40% {
      transform: scale(1);
      opacity: 1;
    }
  }

  /* Chat Input */
  .chat-input {
    padding: 16px;
    border-top: 1px solid var(--border-color);
    background: white;
    flex-shrink: 0;
  }

  .chat-input .form-control {
    border-radius: 20px;
    border-right: none;
    border-top-right-radius: 0;
    border-bottom-right-radius: 0;
    resize: none;
  }

  .chat-input .btn {
    border-radius: 20px;
    border-left: none;
    border-top-left-radius: 0;
    border-bottom-left-radius: 0;
  }

  /* Notifications */
  .notifications-container {
    position: fixed;
    top: 80px;
    right: 20px;
    z-index: 1060;
    max-width: 350px;
    pointer-events: none;
  }

  .notifications-container .alert {
    margin-bottom: 8px;
    border: none;
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.15);
    pointer-events: auto;
    backdrop-filter: blur(10px);
    background: rgba(255, 255, 255, 0.95);
  }

  /* Animations */
  .spin {
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }

  /* Custom Scrollbars */
  .chat-messages::-webkit-scrollbar,
  .chat-users-list::-webkit-scrollbar,
  .ai-suggestions-list::-webkit-scrollbar {
    width: 6px;
  }

  .chat-messages::-webkit-scrollbar-track,
  .chat-users-list::-webkit-scrollbar-track,
  .ai-suggestions-list::-webkit-scrollbar-track {
    background: var(--bg-light);
  }

  .chat-messages::-webkit-scrollbar-thumb,
  .chat-users-list::-webkit-scrollbar-thumb,
  .ai-suggestions-list::-webkit-scrollbar-thumb {
    background: var(--border-color);
    border-radius: 3px;
  }

  .chat-messages::-webkit-scrollbar-thumb:hover,
  .chat-users-list::-webkit-scrollbar-thumb:hover,
  .ai-suggestions-list::-webkit-scrollbar-thumb:hover {
    background: #adb5bd;
  }

  /* Focus states */
  .btn:focus,
  .form-control:focus {
    box-shadow: 0 0 0 0.2rem rgba(13, 110, 253, 0.25);
    border-color: #86b7fe;
  }

  /* Loading states */
  .btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }

  /* Modal improvements */
  .modal-content {
    border-radius: 12px;
    border: none;
    box-shadow: 0 10px 40px rgba(0,0,0,0.2);
  }

  .modal-header {
    border-bottom: 1px solid var(--border-color);
    border-radius: 12px 12px 0 0;
  }

  /* Responsive Design */
  @media (max-width: 768px) {
    :root {
      --chat-width: 100%;
      --header-height: auto;
    }

    .ai-toggle-btn {
      bottom: 100px;
      right: 15px;
      width: 44px;
      height: 44px;
      font-size: 16px;
    }

    .chat-toggle-btn-bottom {
      bottom: 15px;
      right: 15px;
      width: 48px;
      height: 48px;
      font-size: 18px;
    }

    .ai-completion-popup {
      min-width: 300px;
      max-width: calc(100vw - 40px);
      left: 20px !important;
      right: 20px !important;
      width: auto !important;
    }

    .editor-header {
      padding: 12px 15px;
      flex-wrap: wrap;
      min-height: 60px;
    }

    .editor-info {
      gap: 10px;
      order: 1;
      width: 100%;
      margin-bottom: 8px;
    }

    .editor-actions {
      gap: 10px;
      order: 2;
      width: 100%;
      justify-content: space-between;
    }

    .active-users {
      order: 1;
    }

    .action-buttons {
      order: 2;
      gap: 6px;
    }

    .action-buttons .btn span {
      display: none;
    }

    .user-avatar {
      width: 24px;
      height: 24px;
      font-size: 10px;
    }

    .notifications-container {
      right: 10px;
      left: 10px;
      max-width: none;
    }

    .chat-sidebar.open {
      right: 0;
    }

    .editor-container.chat-open {
      right: 100%;
    }

    .status-left, .status-right {
      gap: 8px;
    }

    .status-item {
      font-size: 11px;
    }
  }

  @media (max-width: 480px) {
    .file-name {
      font-size: 14px;
    }

    .branch-badge {
      font-size: 11px;
      padding: 2px 8px;
    }

    .editor-status-bar {
      padding: 0 15px;
      font-size: 11px;
    }

    .chat-input {
      padding: 12px;
    }

    .suggestion-text {
      font-size: 12px;
    }
  }

  /* High contrast mode support */
  @media (prefers-contrast: high) {
    .chat-sidebar {
      border-left: 2px solid var(--border-color);
    }

    .user-avatar {
      border: 2px solid #000;
    }

    .message-content {
      border: 2px solid var(--border-color);
    }

    .ai-completion-popup {
      border: 2px solid var(--border-color);
    }
  }

  /* Reduced motion support */
  @media (prefers-reduced-motion: reduce) {
    .chat-sidebar,
    .editor-container,
    .chat-toggle-btn-bottom,
    .ai-toggle-btn,
    .message,
    .ai-completion-popup {
      transition: none;
      animation: none;
    }

    .typing-dots span {
      animation: none;
    }

    .chat-notification-badge,
    .ai-toggle-btn.active {
      animation: none;
    }
  }
</style>